"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientV1 = void 0;
const qase_api_client_1 = require("qase-api-client");
const is_axios_error_1 = require("../utils/is-axios-error");
const qase_error_1 = require("../utils/qase-error");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const dateUtils_1 = require("./dateUtils");
const form_data_1 = __importDefault(require("form-data"));
const DEFAULT_API_HOST = 'qase.io';
const API_BASE_URL = 'https://api-';
const APP_BASE_URL = 'https://app-';
const API_VERSION = '/v1';
var ApiErrorCode;
(function (ApiErrorCode) {
    ApiErrorCode[ApiErrorCode["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
    ApiErrorCode[ApiErrorCode["FORBIDDEN"] = 403] = "FORBIDDEN";
    ApiErrorCode[ApiErrorCode["NOT_FOUND"] = 404] = "NOT_FOUND";
    ApiErrorCode[ApiErrorCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";
    ApiErrorCode[ApiErrorCode["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
})(ApiErrorCode || (ApiErrorCode = {}));
class ClientV1 {
    logger;
    config;
    environment;
    appUrl;
    runClient;
    environmentClient;
    attachmentClient;
    constructor(logger, config, environment) {
        this.logger = logger;
        this.config = config;
        this.environment = environment;
        const { apiConfig, appUrl } = this.createApiConfig();
        this.appUrl = appUrl;
        this.runClient = new qase_api_client_1.RunsApi(apiConfig);
        this.environmentClient = new qase_api_client_1.EnvironmentsApi(apiConfig);
        this.attachmentClient = new qase_api_client_1.AttachmentsApi(apiConfig);
    }
    createApiConfig() {
        const apiConfig = new qase_api_client_1.Configuration({ apiKey: this.config.api.token, formDataCtor: form_data_1.default });
        if (this.config.api.host && this.config.api.host != DEFAULT_API_HOST) {
            apiConfig.basePath = `${API_BASE_URL}${this.config.api.host}${API_VERSION}`;
            return { apiConfig, appUrl: `${APP_BASE_URL}${this.config.api.host}` };
        }
        apiConfig.basePath = `https://api.${DEFAULT_API_HOST}${API_VERSION}`;
        return { apiConfig, appUrl: `https://app.${DEFAULT_API_HOST}` };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    uploadResults(_runId, _results) {
        throw new Error('Use ClientV2 to upload results');
    }
    async createRun() {
        if (this.config.run.id) {
            return this.config.run.id;
        }
        this.logger.logDebug('Creating test run');
        try {
            const environmentId = await this.getEnvironmentId();
            const runObject = this.prepareRunObject(environmentId);
            const { data } = await this.runClient.createRun(this.config.project, runObject);
            if (!data.result?.id) {
                throw new qase_error_1.QaseError('Failed to create test run');
            }
            this.logger.logDebug(`Test run created: ${JSON.stringify(data)}`);
            return data.result.id;
        }
        catch (error) {
            throw this.processError(error, 'Error creating test run');
        }
    }
    async completeRun(runId) {
        if (!this.config.run.complete) {
            return;
        }
        try {
            await this.runClient.completeRun(this.config.project, runId);
        }
        catch (error) {
            throw this.processError(error, 'Error on completing run');
        }
        if (this.appUrl) {
            const runUrl = `${this.appUrl}/run/${this.config.project}/dashboard/${runId}`;
            this.logger.log((0, chalk_1.default) `{blue Test run link: ${runUrl}}`);
        }
    }
    async uploadAttachments(attachments) {
        if (!this.config.uploadAttachments) {
            return [];
        }
        const uploadedHashes = [];
        for (const attachment of attachments) {
            try {
                this.logger.logDebug(`Uploading attachment: ${attachment.file_path ?? attachment.file_name}`);
                const data = this.prepareAttachmentData(attachment);
                const response = await this.attachmentClient.uploadAttachment(this.config.project, [data]);
                const hash = response.data.result?.[0]?.hash;
                if (hash) {
                    uploadedHashes.push(hash);
                }
            }
            catch (error) {
                this.logger.logError('Cannot upload attachment:', error);
            }
        }
        return uploadedHashes;
    }
    prepareAttachmentData(attachment) {
        if (attachment.file_path) {
            return {
                name: attachment.file_name,
                value: (0, fs_1.createReadStream)(attachment.file_path),
            };
        }
        return {
            name: attachment.file_name,
            value: typeof attachment.content === 'string'
                ? Buffer.from(attachment.content)
                : attachment.content,
        };
    }
    async getEnvironmentId() {
        if (!this.environment)
            return undefined;
        const { data } = await this.environmentClient.getEnvironments(this.config.project, undefined, this.environment, 100);
        return data.result?.entities?.find((env) => env.slug === this.environment)?.id;
    }
    prepareRunObject(environmentId) {
        const runObject = {
            title: this.config.run.title ?? `Automated run ${new Date().toISOString()}`,
            description: this.config.run.description ?? '',
            is_autotest: true,
            cases: [],
            start_time: (0, dateUtils_1.formatUTCDate)(new Date()),
        };
        if (environmentId !== undefined) {
            runObject.environment_id = environmentId;
        }
        if (this.config.plan.id) {
            runObject.plan_id = this.config.plan.id;
        }
        return runObject;
    }
    /**
     * Process error and throw QaseError
     * @param {Error | AxiosError} error
     * @param {string} message
     * @param {object} model
     * @private
     */
    processError(error, message, model) {
        if (!(0, is_axios_error_1.isAxiosError)(error)) {
            return new qase_error_1.QaseError(message, { cause: error });
        }
        const err = error;
        const errorData = err.response?.data;
        const status = err.response?.status;
        switch (status) {
            case ApiErrorCode.UNAUTHORIZED:
                return new qase_error_1.QaseError(`${message}: Unauthorized. Please check your API token.`);
            case ApiErrorCode.FORBIDDEN:
                return new qase_error_1.QaseError(`${message}: ${errorData?.errorMessage ?? 'Forbidden'}`);
            case ApiErrorCode.NOT_FOUND:
                return new qase_error_1.QaseError(`${message}: Not found.`);
            case ApiErrorCode.BAD_REQUEST:
            case ApiErrorCode.UNPROCESSABLE_ENTITY:
                return new qase_error_1.QaseError(`${message}: Bad request\n${JSON.stringify(errorData)}\nBody: ${JSON.stringify(model)}`);
            default:
                return new qase_error_1.QaseError(message, { cause: err });
        }
    }
}
exports.ClientV1 = ClientV1;
